목록
--------------

**BOJ_1003**: [피보나치 함수](https://www.acmicpc.net/problem/1003)
```
- 금방 풀었지만 처음에 각 0과 1의 갯수를 pair로 저장하려다가 pair가 operator+를 지원안하는 것을 깨닫고 오버로딩해보려다가
- 포기하고 쉽게 풀었다. 나중에 pair 연산자 오버로딩을 해보자.
```

**BOJ_1092**: [배](https://www.acmicpc.net/problem/1092)
```
- Yet
```

**BOJ_1149**: [RGB거리](https://www.acmicpc.net/problem/1149)
```c
- i번쨰 집을 칠할 떄는 i-1번째 집만 고려해주면 되므로 첫번째 집부터 칠해가는 방법으로 DP로 구현한다.
[KEY]
for (int i = 1; i < N; i++) {
		D[i][R] = min(D[i - 1][G] + W[i][R], D[i - 1][B] + W[i][R]);
		D[i][G] = min(D[i - 1][R] + W[i][G], D[i - 1][B] + W[i][G]);
		D[i][B] = min(D[i - 1][R] + W[i][B], D[i - 1][G] + W[i][B]);
	}
```

**BOJ_1152**: [단어의 개수](https://www.acmicpc.net/problem/1152)
```c
- while문의 조건으로 cin >> str을 하는 건 vs 에서 계속 무한루프가 돌았고, 결국
- 공백을 모두 센 뒤
cnt = cnt - (s[0] == ' ') - (s[size - 1] == ' ') + 1; 으로 처리하는게 깔끔했다.
```

**BOJ_1157**: [단어 공부](https://www.acmicpc.net/problem/1157)
```c
- 한번에 string으로 받고 각 자리를 대문자로 검사하여 빈도수를 A[0..25]에 저장한다.
- 그 다음 배열 A를 검사하여 가장 많이 나온 알파벳을 뽑는다.
```

**BOJ_1463**: [1로 만들기](https://www.acmicpc.net/problem/1463)
```
- 1에서 [*3 or *2 or +1]을 해가며 거쳐가는 숫자들이 있을때, 
- (1에서 제일 빠르게 해당숫자에 도달하는 단계) == (해당숫자에서 제일 빠르게 1에 도달하는 단계)이다.
```

**BOJ_1507**: [궁금한 민호](https://www.acmicpc.net/problem/1507)
```
- Floyd's Algorithm을 잘 이해하고 있었다면 금방 풀 수 있을 문제였다.
- 도시 간의 최소 경로길이를 구한 D[][]이 구해졌다면, 변형한 Floyd's Algorithm을 적용했을 때 또 다른 최소길이를 갖는 k가 나와서는 안되고,
- (i==k), (j==k)가 아닐 때 k를 거치는 경로가 D[i][j]와 같다면  i와 j는 V1~Vk중 하나 이상의 도시를 거쳐 최소경로를 가지므로 road[i][j]를 지워준다.

+ k가 for문 바깥에 있어야 하는 이유:
+ k가 안쪽에 있으면 다른 경로를 통해 최소값이 구해질 수 있을 D[i][j]를 얻지 못하고, D[i][j]를 결정해버리게 된다.
+ 예를 들어 D[2][3] 다른 vertex에 의해 갱신될 것이라고 하면, 그보다 빨리 계산되는 D[1][3]을 계산할 때
+ D[1][2] + D[2][3]과 비교할 시 갱신될 D[2][3]을 사용하지 못하게 된다.
```

**BOJ_1713**: [후보 추천하기](https://www.acmicpc.net/problem/1713)
```
- 사진틀 밖에 있는 학생이 추천받으면 무조건 사진틀로 올라와야한다. 
- 꽉 차있으면 가장 표가 적은 학생을(2명 이상이면 더 일찍 게시된) 제거하고 올린다.
- 학생의 수가 100명 뿐이 되지 않아서 int배열로 when[i], voted[i]을 사용 학생번호i가 언제 사진틀에 올라왔는지, 몇 표를 얻었는지.
- 사진틀에서 빠질땐 when과 voted를 모두 0으로 해준다.
- 사진틀에 올라와있는지 여부마저 100개의 배열로 저장하면 매번 어느 학생들이 올라와있는지 찾기 위해 100개를 뒤져야 하므로
- set<int>로 관리하여 준다. + set은 오름차순으로 번호를 저장하므로 출력할 때 정렬해줄 필요도 없다.
```

**BJ1759**: [암호 만들기](https://www.acmicpc.net/problem/1759)
```
- 임의로 중복없는 소문자 C개가 주어지고 사전순으로 길이 L로 이루어진 암호조합을 모두 출력하는 문제였다.(3 <= L <= C <= 15)
- 모음은 최소1개 자음은 최소 2개가 들어가야 한다는 조건이 있다.
- 먼저 편의를 위해 입력받은 소문자를 사전순으로 배열하고 alp[0..C-1]에 저장. 모음이면 true를 갖는 같은 크기의 V[0..C-1] 저장.
- alp[0]부터 시작하여 소문자를 포함시키는 경우, 제외시키는 경우로 나누어 내려간다.
- 단, Backtracking문제이므로 내려가서 조합을 완성시킬수 있을 때만 true를 반환하는 promising함수를 정의하여 가지치기를 한다.
- *남은 자음을 모두 합쳐도 2개가 안되거나, 남은 모음을 모두 합쳐도 1개가 안되거나, 길이 L을 맞출 수 없는 경우 false를 반환하였다.*
```

**BOJ_1932**: [정수삼각형](https://www.acmicpc.net/problem/1932)
```
- 아래->위로 가는 DP와 위->아래로 가는 DP를 모두 해보았는데,
- 위로 가는 쪽이 마지막 Max를 한번 더 찾을 필요가 없는만큼 조금 더 빨랐다.
- (+a) 입력이 커지니 ios::sync_with_stdio(false); 있고 없고가 시간 차이가 꽤 난다.
```

**BOJ_1912**: [연속합](https://www.acmicpc.net/problem/1912)
```
- 처음엔 2차원 벡터로 선언하여 DP로 풀었다가 메모리초과를 해결할 수가 없었다.
- 알고보니 2차원으로 늘려 문제를 해결하지 않아도 해결가능했다.
1.최대를 가지는 배열은 음수로는 시작하지 않을것이다. 또한 D[i-1]까지 더한 결과가 음수인 경우도 고려하지 않을것이다.
2.D[i-1]까지 더한것이 양수이면 num[i]와 더해 D[i]에 넣어주고 음수이면 D[i]를 num[i]로 초기화하여 D[i+1]은 최적을 구할 수 있게 한다.
```


