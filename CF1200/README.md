목록
-------
**CF_1279A**[New Year Garland](http://codeforces.com/contest/1279/problem/A)
```
- 연속된 색깔의 램프가 나올수 밖에 없는 경우는 하나의 색깔이 격순으로 나오게 해도 충분치 않은 경우이다.
- 그 말은 제일 숫자가 많은 램프가 나머지 두 색깔 합보다 더 많은 경우이고 정확히는 하나를 더 초과하여 많은 경우이다.
```


**CF_1279B**[Verse For Santa](http://codeforces.com/contest/1279/problem/B)
```
- 스킵할수 있는 cite가 최대 1개인 것을 잘못 이해하여 풀지 못했던 문제이다.
- TIP1 : 모든 cite를 암송할 수 있을 때는 0을 출력하는데, 이는 입력과 동시에 sum에 더하여 마지막에 sum을 확인해주면 된다.
- TIP2 : 순서대로 cite 가중치를 더해갈 때 마지막에 더한 cite를 빼야하는지, 
        아니면 그동안 최대였던 max_cite를 빼야하는지 마지막에 구분해주어야 했다.
```

**CF_1279C**[Stack Of Presents](http://codeforces.com/contest/1279/problem/C)
```
- 배열 where[1..n]은 선물이 쌓여있는 상태를 저장한다.
- b를 받으면서 mx를 업데이트 한다. mx는 선물이 어느 깊이까지 산타의 손이 닿았는지를 나타낸다.
- 당연히, 산타의 손이 닿은 선물은 b와 연동되어 1 단위시간만에 가져갈 수 있도록 정렬되어 있을 것이다.
- 이를 이용하면 굳이 where의 쌓여있는 순서를 재배치하지 않더라도 답을 도출 할 수 있다.
- mx보다 아래에 있는 선물을 가져올 때는 정렬되어 있는 물건이라 할지라도 꺼내고 쌓는데에 시간이 걸리므로 인덱스i를 이용하여
        2 * (where[b] - i) + 1 만에 물건을 꺼내올 수 있다. 그리고 mx를 업데이트 한다.
```

**CF_1281B**[Azamon Web Services](https://codeforces.com/contest/1281/problem/B)

*A 문자열이 B보다 작은 조건이 상세하게 설명되어 있어서 B와 비교하는데에 초점을 맞출수 있지만 사실 A로 만들수 있는 가장 작은 문자열을 만든 뒤 B와 비교하는게 더 쉬웠다. *
