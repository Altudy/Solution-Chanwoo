List ( 2020. 02. 02 )
----

A.
```
- 끝에서부터 검사하여 처음 만나는 홀수를 잡고 다음 원소를 더해가며 짝수가 만들어지는 때에 출력하면 해결
- 문자열의 길이 M이 있을 때 O(M)에 해결가능
```
B. 
```
- 문자열의 원소의 크기를 1씩 줄이는 것이 무한대로 가능하기 때문에 
   각 자리의 원소가 가질수 있는 최소값보다 현재 값이 같거나 큰지 검사해주면 된다.
- 배열의 길이 n일때 O(n)에 해결.
```
C. 
```
- 양쪽 끝에서 k개를 임의로 고른 (k + 1)개의 Case에 대해서 M번째 선택으로 고를 수 있는 원소 2개의 Pair가 총 (m - k + 1)개가 나온다.
- 각 Pair의 2개의 원소 중 큰 값을 고르고, (m - k + 1)개의 값중에 최소가 각 Case에서의 최소한의 값이다.
- 그렇게 모든 Case를 검사하여 답을 도출한다.
- (M-1 <= K인 경우 O(2* (M+1)), M-1 > K인 경우 O(2 * (K+1) * (M-K+1))에 해결.
```

D. 
```
- 먼저 irreducible anagram이 존재하지 않기 위해선 구간의 길이가 2이상이어야 하며, 구간의 모든 문자가 같아야 한다.
- 또한 예외로 구간내에 2개의 알파벳으로만 구성된 경우, 맨 처음과 끝이 같은 문자이면 존재하지 않는다. 
  나머지 경우는 적어도 1개의 irreducible anagram이 존재하게 된다.
- 이 문제는 contructive로 구별되는데, 정답을 빠르게 구하기 위해 입력 전처리를 거치기 때문이다. 
  우선 구별되는 알파벳이 3개 이상인 구간은 무조건 탈락이므로 입력된 문자열 s가 n길이 일때 [0..n-1]에 대하여 
  어디까지가 구별되는 알파벳이 2개 이하로 존재하는지 자료구조를 만들어 저장한다. 최소 O(2 * n)소요.
  그 뒤, 각 질의에 대해서 추가 조건을 처리해 검사해주면 q의 길이가 m일때, O(2*n + m)만에 해결가능하다.
```
E. 

F. 
