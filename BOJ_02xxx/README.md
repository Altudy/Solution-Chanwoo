목록
-----

**BOJ_2156**: [포도주 시식](https://www.acmicpc.net/problem/2156)
```
- DP구현에 까다로웠던 점은 연속으로 3잔의 와인을 마실 수 없다는 것이다.
```

**BOJ_2163**: [초콜릿 자르기](https://www.acmicpc.net/problem/2163)
```
- 초콜릿의 금을 자르게 되면 그와 수직인 방향으로 자르는 횟수는 1만큼 증가하게 된다. 이는 금의 위치가 어디든 달라지지 않는다.
- 문제해결을 위해 필연적으로 모든 금을 잘라야 하므로 (N-1)번의 가로 컷팅과 (M-1)번의 가로 컷팅은 (N-1)*(M-1)의 추가 컷팅을 유발하게 되므로,
- (N과 M, 둘 중 어느쪽의 관점으로 보더라도 추가컷팅량은 같다.) (N-1)*(M-1) + (N-1) + (M-1) = N*M-1이다.
```

**BOJ_2193**: [이친수](https://www.acmicpc.net/problem/2193)
```
- i자릿수의 이친수는 i-1번째 자리엔 0이 와야 한다.
- 그래서 DP를 적용해보면, i-2번째 자리가 1인 D[i-2]와 i-1번째 자리가 1인 D[i-1]을 더해서 D[i]를 구할 수 있다.
- D[i-1]을 그대로 더해주는 이유는, D[i-2]는 i-2번쨰 자리가 0인 경우를 더해주지 못하므로  D[i-1]를 i-1번째 자리가 0인 D[i]에 포함되는 경우의 수로 보는 것이다.

+ 그리고 변수의 범위를 고려해주지 못해서 항상 1번씩 틀리는데, 한번 더 짚고 넘어가자면 이 문제의 경우 가능한 90자리 이진수는 총 2^90, 대략 10^27 이므로 많은 경우가 빠진다고 하더라도 최대가 2*10^9인 int형으로는 틀릴 수밖에 없었다. 
```

**BOJ_2579**: [계단 오르기](https://www.acmicpc.net/problem/2579)
```
- 포도주 시식과 비슷한 면이 있었지만, 코드는 더 짧았다.
- 포도주 시식은 3잔 연속으로 마시지만 않았으면 되어서 최근 3개가 (oxo, oox, xoo)인 경우를 고려해줬지만
- 계단 오르기는 3칸 연속이 불가하다는 조건에, 2칸 이상을 건너뛸 수는 없다는 조건이 추가로 있으므로,
- (xoo, oxo)만 비교해주어야 (oxxoo)같은 상황이 발생하지 않는다.
```

**BOJ_2580**: [스도쿠](https://www.acmicpc.net/problem/2580)
```
- 나는 1~9가 들어가야 하는 각 행, 열과 작은 정사각형의 정보를 나타내는 9개씩 총 27개의 set으로 비어있는 칸에 무엇이 들어가야 할지
 알 수 있도록 했다.
- 맞았지만 매번 find함수로 가지치기를 해서 그런지 시간이 좀 오래걸렸고, 시간을 많이 줄인 코드를 보니 집합이 아닌 9x9이중 배열 3개를 가지고
 row[i][num] 같은 경우는 i번째 행에 num이 들어있는지 않는지 저장하여, 백트래킹으로 구현하였다.
 스도쿠의 판이 크지 않기에 사실 이 방법이 정석인것 같다.
```

**BOJ_2618**: [경찰차](https://www.acmicpc.net/problem/2618)
```
- D[i][j]를 1번경찰차가 Case[i], 2번경찰차가 Case[j]에서 시작한다고 가정하고, 마지막 사건까지 해결하는 최소거리로 저장한다. -> 즉 거꾸로 DP를 적용한다.
- 시간초과를 해결하기 위해 중복계산을 없애주어야 하고, 이때 DP배열에 reference를 적절히 활용하여 접근해야 했다.
```


