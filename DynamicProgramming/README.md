
**BOJ_2156**: [포도주 시식](https://www.acmicpc.net/problem/2156)
```
- DP구현에 까다로웠던 점은 연속으로 3잔의 와인을 마실 수 없다는 것이다.
```

**BOJ_2579**: [계단 오르기](https://www.acmicpc.net/problem/2579)
```
- 포도주 시식과 비슷한 면이 있었지만, 코드는 더 짧았다.
- 포도주 시식은 3잔 연속으로 마시지만 않았으면 되어서 최근 3개가 (oxo, oox, xoo)인 경우를 고려해줬지만
- 계단 오르기는 3칸 연속이 불가하다는 조건에, 2칸 이상을 건너뛸 수는 없다는 조건이 추가로 있으므로,
- (xoo, oxo)만 비교해주어야 (oxxoo)같은 상황이 발생하지 않는다.
```

**BOJ_2618**: [경찰차](https://www.acmicpc.net/problem/2618)
```
- D[i][j]를 1번경찰차가 Case[i], 2번경찰차가 Case[j]에서 시작한다고 가정하고, 마지막 사건까지 해결하는 최소거리로 저장한다. -> 즉 거꾸로 DP를 적용한다.
- 시간초과를 해결하기 위해 중복계산을 없애주어야 하고, 이때 DP배열에 reference를 적절히 활용하여 접근해야 했다.
```

**BOJ_11726**: [2\*n 타일링](https://www.acmicpc.net/problem/11726)
```
- D[1] = 1, D[2] = 2 을 2x1, 2x2일때 타일을 놓는 방법의 수라고 하자.
- i>2일때 D[i]는 D[i-1]에 세로로 세워진 타일 하나를 추가한 것과 D[i-2]에 1x2타일 2개가 쌓여 만들어진 정사각형 타일을 추가한 것의 합이다.
(잠시만 생각해보면 납득할 수 있다.)
- 이를 D[1..N]으로 저장하여 문제를 푼다.
- 이 때, 배열이 뒤로 갈수록 숫자가 exponential하게 커지기 때문에 문제에 맞게 D[i]를 구할 때마다 10007의 나머지를 구해주어서 런타임에러가 나지 않게 한다. *런타임에러란: 컴파일이 완료된 후 프로그램 실행 중 발생하는 에러라는 뜻이다.*
```

**BOJ_17127**: [벚꽃이 정보섬에 피어난 이유](https://www.acmicpc.net/problem/17127)
```
- 곱셈으로 구해지는 4개의 그룹이 중복으로 계산하는 경우가 많으므로
- D[i][j] == X[i]*X[i+1]*~*X[j-1]*X[j] 을 맵핑하여 좀 더 효율적으로 계산한다.
```
